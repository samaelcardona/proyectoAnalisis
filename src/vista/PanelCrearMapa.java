/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package vista;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import modelo.Calle;
import modelo.PuntosLimiteCuadricula;

/**
 *
 * @author SAMAEL
 */
public class PanelCrearMapa extends javax.swing.JPanel implements MouseMotionListener,MouseListener,KeyListener{

     int x=20;
    int y=10;
    Calle calle;
    PuntosLimiteCuadricula [][] matrizPuntosLimitesCuadriculaMapa=new PuntosLimiteCuadricula[20][10];
    String [][] matrizLetrasElementosInternosCuadriculaMapa=new String[20][10];
    int [][] matrizCuadriculaMapa=new int[20][10];
    private FrameCrearMapa frame;
    int contadorDeCalles=0;
    int contadorDeEdificios=0;
    int contadorDeArboles=0;
  
    
    /**
     * Creates new form PanelCrearMapa
     */
    public PanelCrearMapa() {
        initComponents();
        
        addKeyListener(this);
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
        addMouseListener(this);
        addMouseMotionListener(this);
        
        for (int i = 0; i < 20; i++) {
            for (int j = 0; j < 10; j++) {
             matrizPuntosLimitesCuadriculaMapa[i][j]=new PuntosLimiteCuadricula();
             matrizLetrasElementosInternosCuadriculaMapa[i][j]="";
            }
        }
        
       
        
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setMaximumSize(new java.awt.Dimension(1120, 560));
        setMinimumSize(new java.awt.Dimension(1120, 560));
        setPreferredSize(new java.awt.Dimension(1120, 560));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1120, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 560, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g); //To change body of generated methods, choose Tools | Templates.
        ///aca se grafica las lineas horizontales para la cuadricula        
        for (int i = 0; i < x; i++) {
            g.drawLine((i * 56) - 3, 0, (i * 56) - 3, 560);
        }
        
        for (int i = 0; i < x; i++) {
           g.drawLine((i * 56) + 3, 0, (i * 56) + 3, 560);
        }
        
        g.drawLine(1114, 0, 1114, 560);

        ///aca se grafica las lineas  verticales para la cuadricula.
        g.drawLine(3, 0, 3, 560);
        for (int i = 0; i < y; i++) {
            g.drawLine(0, (i * 56) - 3, 1120, (i * 56) - 3);
        }
        for (int i = 0; i < y; i++) {
            g.drawLine(0, (i * 56) + 3, 1120, (i * 56) + 3);
        }
        g.drawLine(0, 557, 1120, 554);

        //llenar matriz 
        for (int i = 1; i <= x; i++) {
            for (int j = 1; j <= y; j++) {
                matrizPuntosLimitesCuadriculaMapa[i-1][j-1].setX1(((i-1)*56));
                matrizPuntosLimitesCuadriculaMapa[i-1][j-1].setX2((i*56)-3);
                matrizPuntosLimitesCuadriculaMapa[i-1][j-1].setY1(((j-1)*56));
                matrizPuntosLimitesCuadriculaMapa[i-1][j-1].setY2((j*56)-3);
            }
        }
        
        if (calle != null) {
            g.drawImage(calle.getImagen().getImage(), calle.getX(), calle.getY(), calle.getAncho(), calle.getAlto(), this);
            g.setColor(Color.white);
            g.drawRect(calle.getX(), calle.getY(), calle.getAncho(), calle.getAlto());
        }
        
        repaint();
    
    }

    public void recibirFrameCrearMapa(FrameCrearMapa frameRecibido){
        this.frame=frameRecibido;
    }
    
    
    @Override
    public void mouseDragged(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        
    
    }

    @Override
    public void mouseMoved(MouseEvent e) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        if (calle != null) {
            calle.setX(e.getX()-23);
            calle.setY(e.getY()-23);
            repaint();
        }
        
    
    }

    @Override
    public void mouseClicked(MouseEvent e) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    
        int x=(int)e.getPoint().getX();
        int y=(int)e.getPoint().getY();
        
        int [] cuadroSeleccionado=new int[2];
        cuadroSeleccionado=retornarPosicionCuadriculaSeleccionada(x, y);
        
        
        if (cuadroSeleccionado!=null) {
             if (!matrizLetrasElementosInternosCuadriculaMapa[cuadroSeleccionado[0]][cuadroSeleccionado[1]].equals("")) {
                 System.out.println("verifique posicion de calle");
            }
            if (calle!=null&&matrizLetrasElementosInternosCuadriculaMapa[cuadroSeleccionado[0]][cuadroSeleccionado[1]].equals("")) {
                FormularioParaLaTomaDeDatosSegunSamaelCardonaClavijo formularioTomaDeDatos=new FormularioParaLaTomaDeDatosSegunSamaelCardonaClavijo();
                formularioTomaDeDatos.recibirPanel(this,cuadroSeleccionado[0],cuadroSeleccionado[1]);
                formularioTomaDeDatos.setVisible(true);
            }
           
            if (true) {
                
            }
            if (true) {
                
            }
        }

        /*
        //ciclo para mostrar las matrices de limites
        String cadena;
    
            System.out.println("");

              for (int i = 0; i < 10; i++) {
                  cadena="";
                for (int j = 0; j < 20; j++) {
                   cadena=cadena+"para x "+j+" y "+i+"[ x1 "+matrizPuntosLimitesCuadriculaMapa[j][i].getX1()+" x2 "+matrizPuntosLimitesCuadriculaMapa[j][i].getX2()+" y1 "+matrizPuntosLimitesCuadriculaMapa[j][i].getY1()+" y2 "+matrizPuntosLimitesCuadriculaMapa[j][i].getY2()+"] ";
                }
                  System.out.println(cadena);
            }

              System.out.println("pos x " + e.getX());
              System.out.println("pos y " + e.getY());
        */
        
        /*
        //ciclo para mostrar las matrices de elementos 
        String cadena;
    
            System.out.println("");

            System.out.println("    0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20 ");
              for (int i = 0; i < 10; i++) {
                  cadena=i+" ";
                for (int j = 0; j < 20; j++) {
                   cadena=cadena+"  "+matrizLetrasElementosInternosCuadriculaMapa[j][i];
                }
                  System.out.println(cadena);
            }
        */    
              
        if (frame!=null) {
             frame.getjRadioButton1().setSelected(false);
             frame.getjRadioButton10().setSelected(false);
             frame.getjRadioButton11().setSelected(false);
             frame.getjRadioButton12().setSelected(false);
             frame.getjRadioButton13().setSelected(false);
             frame.getjRadioButton14().setSelected(false);
             frame.getjRadioButton15().setSelected(false);
             frame.getjRadioButton16().setSelected(false);
             frame.getjRadioButton9().setSelected(false);
             frame.getjRadioButton8().setSelected(false);
             frame.getjRadioButton7().setSelected(false);
             frame.getjRadioButton6().setSelected(false);
             frame.getjRadioButton5().setSelected(false);
             frame.getjRadioButton4().setSelected(false);
             frame.getjRadioButton3().setSelected(false);
             frame.getjRadioButton2().setSelected(false);
        }
    }

    @Override
    public void mousePressed(MouseEvent me) {
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseReleased(MouseEvent me) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseEntered(MouseEvent e) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        if (calle != null) {
            calle.setX(e.getX());
            calle.setY(e.getY());
            repaint();
        }
    
    }

    @Override
    public void mouseExited(MouseEvent me) {
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyTyped(KeyEvent ke) {
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent ke) {
     //   throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyReleased(KeyEvent ke) {
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public int [] retornarPosicionCuadriculaSeleccionada(int x, int y){
        
        boolean encontroX=false;
        boolean encontroY=false;
        int i=0;
        int j=0;
        int [] datosXY=new int[2];

        //para encontrar limites en x 
        while (i<20&&encontroX==false) {    
            if (matrizPuntosLimitesCuadriculaMapa[i][j].getX1()<=x&&matrizPuntosLimitesCuadriculaMapa[i][j].getX2()>=x) {
                    encontroX=true;
                    datosXY[0]=i;
                }
            i++;
        }
        
        //para encontrar limites en y despues de haber encontrado x
        if (encontroX==true) {
            while (j<10&&encontroY==false) {                
                if (matrizPuntosLimitesCuadriculaMapa[datosXY[0]][j].getY1()<=y&&matrizPuntosLimitesCuadriculaMapa[datosXY[0]][j].getY2()>=y) {
                    encontroY=true;
                    datosXY[1]=j;
                }
                j++;  
            }
        }
        else{
            System.out.println("verifique posiciones seleccionadas");
        }
        if (encontroY==true) {
            return datosXY;  
        }
          return null;
    }
    
    
    
    
    public void recibirDatosFormularioYmodificarCalle(int x, int y,String tipo, String sentido){
        calle.setSentido(sentido);
         calle.setTipo(tipo); 
         if(!calle.getSentido().equals("")||!calle.getTipo().equals("")) { 
                    
                  
                    
                    if ("Urbana".equals(calle.getTipo())) {
                        calle.setVelocidad(60);
                        if ("Derecha".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="r";
                            contadorDeCalles++;
                        }
                        if ("Izquierda".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="l";
                            contadorDeCalles++;
                        }
                        if ("Doble sentido".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="h";
                            contadorDeCalles++;
                        }
                    }
                    
                    if ("Carretera".equals(calle.getTipo())) {
                        calle.setVelocidad(100);
                        if ("Derecha".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="R";
                            contadorDeCalles++;
                        }
                        if ("Izquierda".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="L";
                            contadorDeCalles++;
                        }
                        if ("Doble sentido".equals(calle.getSentido())) {
                            calle.setId(contadorDeCalles);
                            matrizLetrasElementosInternosCuadriculaMapa[x][y]="H";
                            contadorDeCalles++;
                        }
                    }
                    
                }
         calle=null;
    }
    
    
    
    
    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public Calle getCalle() {
        return calle;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setCalle(Calle calle) {
        this.calle = calle;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

   
}
